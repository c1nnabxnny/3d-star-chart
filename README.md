# 3d-star-chart
The goal of this project is to set up a 3D environment made of real star data from outer space, so that we can artistically render and explore outer space.

## Code Structure:

# Part One: Getting the data

This section of the code only needs to be used once, so you can connect to the Skyfield api and download the data you need (in this case, it's set up to download the Hipparcos data, but you can easily make a few changes to the starchart.py script to download data from whichever database you want). Once you have the data locally on your machine, you don't need to run this section of the code again.

1. starchart.py

This script connects to the skyfield api. Skyfield computes positions for the stars, planets, and satellites in orbit around the Earth. Its results should agree with the positions generated by the United States Naval Observatory and their Astronomical Almanac to within 0.0005 arcseconds (half a “mas” or milliarcsecond). This script scrapes data from the Hipparcos star catalogue to get the coordinates of all the stars in the database.
It converts the raw data into x,y,z coordinates that can be plotted on a scatterplot graph. Then it writes all the coordinates into a 2D array in a file called "coordinates.js". It then charts all the stars into a 3d scatterplot, however, this step was just for testing purposes to ensure the code worked, it is not necessary to include.

3. coordinates.js

This file contains an extremely large 2D array of all the coordinates in the Hipparcos catalogue, which is 118,219 stars that each have 3 coordinate points (x,y,z) that are very large numbers. It's a truly large amount of raw data. I am trying not to be intimidated by this. I am also trying not to break my computer. We will see how this goes.

4. .gitignore

If you're adding this project to github, make sure to include this and put the name of your coordinates database on here (in my case, coordinates.js) so that you don't accidentally try to upload that file to github while pushing commits. If you do that, I don't know exactly what will happen to your computer and/or the internet, but I do know it will be very bad. Don't do that. Make sure you have this file!!

5. package.json

This is where you can add all your project depencies. I already can't remember what dependencies I downloaded. But you'll figure out which ones you need to install based on the error messages you get. lol.

# Part 2: Sorting the data

Now that we have the data, we need to sort it so we don't break our computers. The most efficient way to do this, to my current knowledge, is to sort the database into an r-tree or a k-d tree in order of distance from the origin point (0, 0, 0). then, sort the sorted tree into buckets. then, set a script so that the engine only renders the stars that are in the same bucket as the user location. this way the computer doesn't try to render the entire large dataset at once, which would immediately overwhelm and crash the machine, and instead it only renders the part we currently need to see, which is a much more manageable dataset to work with. from there, we can probably further optimize rendering (and we also probably should), but I will deal with that part once I get there.

1. passdatafromjs.cpp

This script allows data to be passed from a javascript file to a C++ file. We can use this on coordinates.js to re-compile the data so that we can use it to build our sorted backend structure in C++. C++ is both better for managing large data structures than Javascript, and is also the language used in Unreal engine, which is where I plan on implementing this environment.

To import an exported module from a js file to a c++ file, you can use a Javascript engine such as V8, SpiderMonkey, or ChakraCore. These engines allow you to execute js code in a c++ environment and provide an API to access the exported modules. This script uses the V8 engine.

I think this code is a bit messy atm because I have the javascript file name hardcoded in. If I do go back and make edits, one thing I would like to change is passing in the js file name instead, so that it's easier to manage maintenance and scalability of the project. It's also just cleaner code. But there are limits to what my brain can manage to do in one coding session, and for now, as long as it works it is good enough. lol.

You may need to update your include paths to get this to work, at least I did. On my linux system, the correct path I needed to add was /usr/<put the rest in here lol>

